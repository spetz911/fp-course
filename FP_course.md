
Каким я вижу функциональное программирование?

+ lambda calculus
+ LISP
+ ADT
+ macros

+ carryng, Y-combinator, безточечное программирование
+ continuations, shift/reset
+ pure data structures
+ polimorphic, existentional types
+ lazy evaluation
+ async, futures, reactive programming
+ monads, functors
+ Existentional types, Depended types
+ OOP/FP like Odersky
+ Type Systems, Hindley-Milner + Damas, Type Inference
+ SECD Landin, Categorial Abstract Mashine, combinatory logic
+ EDSL, lex, yacc
+ оптимизация программ, case, дефорестизация, Fusion Streams
+ pattern matching
+ DSL's
+ lambda lifing
+ Lens, Zippers



0. Введение
===========

заполнить анкету

рассказ про LISP интерпретатор, подмножество R6RS, возможности racket/guile

что есть функциональное программирование, не только map/reduce

рекурсия -- мем башорга, рекурсия это goto в FP

Основная идея ФП: неизменяемое состояние. Пример с Excel. История языков программирования, эзотерические языки. Парадигмы программирования и базовые модели вычислений. Примеры на F#, базовый синтаксис, общие сведения о системе типов, функции многих переменных и каррирование. Полиморфные типы. Пример решения квадратного уравнения. Сопоставление с образцом. Вычисление и визуализация множества Мандельброта, каррирование, примеры рекурсивных функций и функций высшего порядка, примеры функциональной декомпозиции задачи, разложение ряда Тейлора


1. Функциональное программирование на Haskell, ADT, деревья.
============================================================

выражение деревьев в ADT

связь с грамматиками, CFG, Backus–Naur Form, Chomsky normal form


*самому вспомнить что такое LL, LR -- в чем разница и где ключи от танка

Списки в функциональных языках программирования, базовые операции и функции высших порядков, хвостовая рекурсия. Примеры: вычисление простых чисел, генерация перестановок. Матрицы. Порядковое представление списков и матриц. Массивы. Прямоугольные и непрямоугольные массивы. Треугольник Паскаля. Сравнение списков и массивов. Функциональные структуры данных Криса Окасаки. Реализация очереди на списках. Зиппер. Пример: моделирование машины Тьюринга на F#

Представление деревьев в функциональных языках. Двоичные деревья и деревья общего вида. Синтаксические деревья и деревья выражений. Разбор выражения в дерево и вычисление выражения. Деревья поиска. Сортировка с помощью дерева поиска.


2. Лямбда исчисление, комбинаторы, неподвижная точка
=================================================================

предложить использовать языки Scala(Java), Haskell, F#(OCaml), Python, C++, JavaScript, Lisp, Erlang.

Язык программирования LISP. Семантика функциональных языков. Реализация функциональных языков (Eval/Apply). SECD-машина Ландина. КАМ. Круглый стол: сравнение функционального и императивного программирования. Функциональное программирование в реальной жизни. Роль F# в экосистеме языков программирования.
Лямбда-исчисление. Построение функционального ЯП на базе лямбда-исчисления
Лямбда-исчисление. Редукция термов. Комбинаторы


реализовать парсер кода в AST, поддержку чисел

реализовать lamdba, абстракцию, аппликацию, beta-редукцию

дополнительно -- присваивание, оператор if

что означает равенство, = в лямда-исчислении

откуда берутся комбинаторы?

carryng, Y-combinator, безточечное программирование

Основные понятия лямбда-исчисления. Абстракция, аппликация. Редукция термов, различные виды редукции. Аппликативный и нормальный порядок редукции. Теорема Черча-Россера. Теорема стандартизации. Комбинаторы и комбинаторная логика. Базисы комбинаторов. Комбинатор неподвижной точки. Сведение рекурсии к комбинатору неподвижной точки. Примеры реализации функциональных программ на F# с помощью комбинаторов. Построение языка программирования на базе лямбда-исчисления. Нумералы, числа Черча.


Разбор ряда задач на редукцию термов, на преобразование выражений комбинаторной логики к лямбда-исчислению и обратно, на сведение рекурсивного определения к комбинатору неподвижной точки, на приведение функциональной программы к комбинаторному виду (без аргументов).



3. Нормальный и аппликативный порядок вычислений
================================================

Реализация окружения и стека вызовов. *не чистая, через HashMap

В прологе свой, особый путь: порядок вычислений через унификацию

Реализация макросов.

квотирование, объяснение unquote-splicing


4. Lazy eval
============

Роль ленивых вычислений в ФП и Хаскеле

реализация delay/force

работа с ленивыми последовательностями на лиспе


*у Одерского домашка bloxoz на эту тему

*расшаренные переменные, списки

Построение частотного словаря текстового файла. Выделение имен (слов, начинающихся с большой буквы). Построение графа зависимостей слов на основе вхождения слов в одно предложение. Использование FsharpChart для построения графиков.


5. Delimited continuations, CPS
================================


Замыкания. Программирование с продолжениями. Сведение нелинейной рекурсии к хвостовой с помощью продолжений. Программирование с продолжениями (continuation passing style).



реализация call/cc

реализация shift, reset

реализация питоновского yield

перевод программы в CPS, преимущества такого представления


*связь со строгой типизацией, монада Cont


```
реализация:

(reset val) => val
(reset E[(shift k expr)]) => (reset ((lambda (k) expr)
                                     (lambda (v) (reset E[v]))))
  ; where E has no reset


пример:

(reset
  (begin
    (shift k (cons 1 (k (void))))
    (shift k (cons 2 (k (void))))
    null))


1й шаг:

(reset ((lambda (k) (cons 1 (k (void))))
	     (lambda (vv) (reset
						  (begin
						    vv
						    (shift k (cons 2 (k (void))))
						    null)))))


2й шаг:

(reset ((lambda (k) (cons 2 (k (void))))
        (lambda (vv2) (reset ((lambda (k) (cons 1 (k (void))))
	     (lambda (vv1) (reset
		  (begin
		    vv1
		    (vv2)
		    null))))))))


добавление питона:

(define (stream-yield x) (shift k (stream-cons x (k (void)))))


(define lazy-example
   (reset (begin
           (stream-yield 1)
           (stream-yield 2)
           (stream-yield 3)
           stream-null)))


```




6. Pure FP data structures
==========================

реализация set как у Одерского

сложность вставки, нахождения элементов

Кошерное представление векторов, деревьев, множеств, списков




  /**
   * Indicates whether a set contains a given element.
   */
  def contains(s: Set, elem: Int): Boolean = s(elem)

  /**
   * Returns the set of the one given element.
   */
  def singletonSet(elem: Int): Set = ???

  /**
   * Returns the union of the two given sets,
   * the sets of all elements that are in either `s` or `t`.
   */
  def union(s: Set, t: Set): Set = ???

  /**
   * Returns the intersection of the two given sets,
   * the set of all elements that are both in `s` and `t`.
   */
  def intersect(s: Set, t: Set): Set = ???

  /**
   * Returns the difference of the two given sets,
   * the set of all elements of `s` that are not in `t`.
   */
  def diff(s: Set, t: Set): Set = ???

  /**
   * Returns the subset of `s` for which `p` holds.
   */
  def filter(s: Set, p: Int => Boolean): Set = ???


  /**
   * Returns whether there exists a bounded integer within `s`
   * that satisfies `p`.
   */
  def exists(s: Set, p: Int => Boolean): Boolean = ???

  /**
   * Returns a set transformed by applying `f` to each element of `s`.
   */
  def map(s: Set, f: Int => Int): Set = ???









7. Futures
=========================================

работа с потоками, асинхронные вычисления







8. Монады и Функторы
====================

смотреть Learn Haskell For Great Good

списки, futures...

Оформление продолжения в виде монады. Основные свойства монад. Монада Maybe, монады ввода-вывода, монада недетерминированных вычислений. Computational workflows (монадические выражения) в F#. Метапрограммирование. Программирование асинхронных и параллельных вычислений с помощью монады async.

```


class Functor f where  
    fmap :: (a -> b) -> f a -> f b  


instance Functor IO where  
    fmap f action = do  
        result <- action  
        return (f result)  


class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b 

instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something




class Monad m where  
    return :: a -> m a  
  
    (>>=) :: m a -> (a -> m b) -> m b  
  
    (>>) :: m a -> m b -> m b  
    x >> y = x >>= \_ -> y  
  
    fail :: String -> m a  
    fail msg = error msg  


пример:

instance Monad Maybe where  
    return x = Just x  
    Nothing >>= f = Nothing  
    Just x >>= f  = f x  
    fail _ = Nothing  


### Monad laws

#### Left identity

return x >>= f is the same damn thing as f x

#### Right identity

m >>= return is no different than just m

#### Associativity

Doing (m >>= f) >>= g is just like doing m >>= (\x -> f x >>= g)










```







9. Типизания
========================

Type Inference, алгоритм Hindley-Milner (+ Damas)
*см. статью в англ. вики

Системы типов в ЯП


10. Existentional types, Depended types, OOP+FP видео Одерского
===============================================================

вычисления на типах, шаблоны C++



11. Reactive programming, Async, 2й курс Одерского
=====================================================

Акторы как модель исчисления(вики)

+ агенты, акторы

Агенты F#. Реактивное программирование и его реализация на F# с помощью асинхронных вычислений. Три модели потоковых вычислений (списки, последовательности, реактивная/observables). Пример: определение настроения твиттера в реальном времени. Реактивное программирование котроллеров LeapMotion и Kinect. Метапрограммирование и квотирование.


12. КомбинАторная логика
=====================================================

Вычисления на комбинатроах, КАМ.
SECD машина Ландина, появление OCaml.


13. Подведение итогов
=====================

Групповая дискуссия/круглый стол с разбивкой на 2 команды (2 дискуссии, чтобы всего было 4 команды по 5-6 чел.), с трансляцией в интернет в реальном времени. Итоговая лекция про применение функциональных языков в реальных проектах и про роль F# в экосистеме современных языков.


Работа группами по 3-4 человека. Необходимо реализовать простейшую поисковую систему: асинхронный crawler, веб-интерфейс с использованием WebSharper, простейшую базу данных (в памяти, SQL Server или NoSQL), в идеале - поддержку Windows Azure.




//===============================================================================================================================

PS 
не сводить к курсу компиляторов
не стоит галопом по европам
дать возможность отстающим писать на racket
дать примеры лаб на разных языках, чтобы быстрее соображали
реализовать подобие Ejudge для аавтоматической сдачи лаб
AST, reflections, JIT, GC не стоит давать
получать 30% фидбэк прежде чем переходить к след теме
подготовить материалы, которых достаточно для понимания
не уходить в теорию языков, грамматик, типов итд
практическая направленность курса -- лучше один раз попробовать чем глубоко копать
посмотреть книгу Лерн Хаскель фор грейт гуд
нарисовать mind-map как все взаимосвязано






